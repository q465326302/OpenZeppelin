# ERC 721
这组接口、合约和工具都与[ERC721不可替代代币标准](https://eips.ethereum.org/EIPS/eip-721)相关。
>TIP
要了解如何创建ERC721代币的详细步骤，请阅读我们的*ERC721指南*。

EIP规定了四个接口：

* *IERC721*：所有兼容实现所需的核心功能。
* *IERC721Metadata*：可选扩展，添加名称、符号和令牌URI，几乎总是包括在内。
* *IERC721Enumerable*：可选扩展，允许在链上枚举令牌，通常不包括在内，因为它需要大量的gas开销。
* *IERC721Receiver*：如果合约想要通过safeTransferFrom接受令牌，则必须实现的接口。

OpenZeppelin Contracts提供了所有四个接口的实现：

* *ERC721*：核心和元数据扩展，带有基本URI机制。
* *ERC721Enumerable*：可枚举扩展。
* *ERC721Holder*：接收器接口的基本实现。

此外还有几个扩展：

* *ERC721Consecutiv*e：遵循ERC721的实现，用于在构造期间批量铸造令牌。
* *ERC721URIStorage*：一种更灵活但更昂贵的存储元数据的方法。
* *ERC721Votes*：支持投票和投票委托。
* *ERC721Royalty*：一种向ERC2981发送版税信息的方式。
* *ERC721Pausable*：暂停合约操作的原语。
* *ERC721Burnable*：令牌持有人烧毁自己的令牌的方法。
* *ERC721Wrapper*：包装器，用于创建由另一个ERC721支持的ERC721，具有存款和提款方法。与*ERC721Votes*一起使用非常有用。

这个核心合约集旨在不具有主观性，允许开发人员访问ERC721的内部函数（如*_mint*），并以他们喜欢的方式将它们公开为外部函数。另一方面，*ERC721预设*（如*ERC721PresetMinterPauserAutoId*）使用有主观性的模式设计，为开发人员提供可用的、可部署的合约。

## 核心

### IERC721
```
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
```
ERC721兼容合约所需的接口。

**FUNCTIONS**
balanceOf(owner)
ownerOf(tokenId)
safeTransferFrom(from, to, tokenId, data)
safeTransferFrom(from, to, tokenId)
transferFrom(from, to, tokenId)
approve(to, tokenId)
setApprovalForAll(operator, approved)
getApproved(tokenId)
isApprovedForAll(owner, operator)

IERC165
supportsInterface(interfaceId)

**EVENTS**
Transfer(from, to, tokenId)
Approval(owner, approved, tokenId)
ApprovalForAll(owner, operator, approved)

#### balanceOf(address owner) → uint256 balance
外部#
返回所有者账户中的令牌数量。

#### ownerOf(uint256 tokenId) → address owner
外部#
返回tokenId代币的所有者。
要求：
* tokenId必须存在。

#### safeTransferFrom(address from, address to, uint256 tokenId, bytes data)
外部#
安全地从from将tokenId代币转移到to。
要求：
* from不能为零地址。
* to不能为零地址。
* tokenId代币必须存在并由from拥有。
* 如果调用者不是from，则必须通过*approve*或*setApprovalForAll*获得批准以移动此代币。
* 如果to指向智能合约，则必须实现*IERC721Receiver.onERC721Received*，在安全转移时调用。

发出*Transfer*事件。

#### safeTransferFrom(address from, address to, uint256 tokenId)
外部#
安全地将tokenId代币从from转移到to，首先检查合约接收方是否知道ERC721协议，以防止代币被永久锁定。
要求：
* from不能为零地址。
* to不能为零地址。
* tokenId代币必须存在并由from拥有。
* 如果调用者不是from，则必须通过*approve*或*setApprovalForAll*获得允许移动此代币。
* 如果to指的是智能合约，则必须实现*IERC721Receiver.onERC721Received*，该函数在安全转移时被调用。
发出一个*Transfer*事件。

#### transferFrom(address from, address to, uint256 tokenId)
外部#
将tokenId代币从from转移到to。

>WARNING
请注意，调用者负责确认接收方能够接收ERC721，否则它们可能永久丢失。使用safeTransferFrom可以防止丢失，但调用者必须理解这会添加一个外部调用，可能会创建重入漏洞。
要求：
* from不能是零地址。
* to不能是零地址。
* tokenId代币必须由from拥有。
* 如果调用者不是from，则必须通过*approve*或*setApprovalForAll*获得批准以移动此代币。

发出*Transfer*事件。

#### approve(address to, uint256 tokenId)
外部#
允许将tokenId令牌转移给另一个账户。当该令牌被转移时，批准将被清除。
一次只能批准一个账户，因此批准零地址会清除先前的批准。
要求：
* 调用者必须拥有该令牌或是已批准的操作员。
* tokenId必须存在。
发出一个*Approval*事件。

#### setApprovalForAll(address operator, bool approved)
批准或移除操作员作为呼叫者的操作员。操作员可以为呼叫者拥有的任何代币调用*transferFrom*或*safeTransferFrom*。

要求：
* 操作员不能是呼叫者本身。

发出一个*ApprovalForAll*事件。

#### getApproved(uint256 tokenId) → address operator
外部#
返回 tokenId 令牌批准的帐户。
要求：
* tokenId 必须存在。

#### isApprovedForAll(address owner, address operator) → bool
返回运营商是否被允许管理所有所有者的资产。

请参阅*setApprovalForAll*

#### Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
事件#
当 tokenId 代币从 from 转移到 to 时发出。

#### Approval(address indexed owner, address indexed approved, uint256 indexed tokenId)
事件#
当所有者启用批准以管理tokenId令牌时发出。

#### ApprovalForAll(address indexed owner, address indexed operator, bool approved)
事件#
当所有者启用或禁用（批准）操作员管理其所有资产时发出。
